import { NostrEvent } from "@nostrify/nostrify";
import {
  DraftTrack,
  DraftAlbum,
  CreateDraftTrackData,
  CreateDraftAlbumData,
  DRAFT_TRACK_KIND,
  DRAFT_ALBUM_KIND,
  TRACK_KIND,
  ALBUM_KIND,
} from "@/types/drafts";

// Type for Nostr signer with NIP-44 support
interface NostrSigner {
  getPublicKey: () => Promise<string>;
  signEvent: (event: NostrEvent) => Promise<NostrEvent>;
  nip44?: {
    encrypt: (pubkey: string, plaintext: string) => Promise<string>;
    decrypt: (pubkey: string, ciphertext: string) => Promise<string>;
  };
}

// Encrypt draft content using NIP-44
export async function encryptDraftContent(
  signer: NostrSigner,
  userPubkey: string,
  content: unknown
): Promise<string> {
  if (!signer.nip44) {
    throw new Error("NIP-44 encryption not supported by signer");
  }

  return await signer.nip44.encrypt(userPubkey, JSON.stringify(content));
}

// Decrypt draft content using NIP-44
export async function decryptDraftContent(
  signer: NostrSigner,
  userPubkey: string,
  encryptedContent: string
): Promise<unknown> {
  if (!signer.nip44) {
    throw new Error("NIP-44 decryption not supported by signer");
  }

  const decrypted = await signer.nip44.decrypt(userPubkey, encryptedContent);
  return JSON.parse(decrypted);
}

// Create future track event structure from draft data
export function createFutureTrackEvent(
  data: CreateDraftTrackData
): Omit<NostrEvent, "created_at"> & { created_at?: number } {
  const identifier =
    data.draftId?.replace("draft-", "track-") ||
    `track-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  const tags: string[][] = [
    ["d", identifier],
    ["title", data.title],
    ["genre", data.genre],
    ["url", data.audioUrl],
    ["explicit", data.explicit.toString()],
  ];

  // Add optional tags
  if (data.description) {
    tags.push(["description", data.description]);
  }

  if (data.price && data.price > 0) {
    tags.push(["price", data.price.toString(), "sat"]);
  }

  if (data.coverUrl) {
    tags.push(["image", data.coverUrl]);
  }

  // Add custom tags
  data.tags.forEach((tag) => {
    tags.push(["t", tag]);
  });

  // Add artist reference if provided
  if (data.artistId) {
    tags.push(["p", data.artistId]);
  }

  return {
    kind: TRACK_KIND,
    content: data.description || "",
    tags,
    pubkey: "", // Will be set by signer
    id: "", // Will be generated by signer
    sig: "", // Will be generated by signer
  };
}

// Create future album event structure from draft data
export function createFutureAlbumEvent(
  data: CreateDraftAlbumData
): Omit<NostrEvent, "created_at"> & { created_at?: number } {
  const identifier =
    data.draftId?.replace("draft-", "album-") ||
    `album-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  const tags: string[][] = [
    ["d", identifier],
    ["title", data.title],
    ["artist", data.artist],
    ["genre", data.genre],
    ["explicit", data.explicit.toString()],
  ];

  // Add optional album metadata
  if (data.description) {
    tags.push(["description", data.description]);
  }

  if (data.price && data.price > 0) {
    tags.push(["price", data.price.toString(), "sat"]);
  }

  if (data.coverUrl) {
    tags.push(["image", data.coverUrl]);
  }

  if (data.releaseDate) {
    tags.push(["released_at", new Date(data.releaseDate).getTime().toString()]);
  }

  if (data.upc) {
    tags.push(["upc", data.upc]);
  }

  if (data.label) {
    tags.push(["label", data.label]);
  }

  // Add track references
  data.tracks
    .sort((a, b) => a.trackNumber - b.trackNumber)
    .forEach((track) => {
      tags.push(["e", track.eventId, "", track.title]);
      tags.push(["track", track.trackNumber.toString(), track.eventId]);
    });

  // Add custom tags
  data.tags.forEach((tag) => {
    tags.push(["t", tag]);
  });

  // Add artist reference if provided
  if (data.artistId) {
    tags.push(["p", data.artistId]);
  }

  return {
    kind: ALBUM_KIND,
    content: data.description || "",
    tags,
    pubkey: "", // Will be set by signer
    id: "", // Will be generated by signer
    sig: "", // Will be generated by signer
  };
}

// Parse draft event into DraftTrack
export async function parseDraftTrack(
  draftEvent: NostrEvent,
  signer: NostrSigner,
  userPubkey: string
): Promise<DraftTrack | null> {
  try {
    const draftId = draftEvent.tags.find((tag) => tag[0] === "d")?.[1];
    const title =
      draftEvent.tags.find((tag) => tag[0] === "title")?.[1] ||
      "Untitled Draft";

    if (!draftId) {
      console.error("Draft event missing 'd' tag");
      return null;
    }

    // Check if content is empty (deleted draft)
    if (!draftEvent.content || draftEvent.content.trim() === "") {
      return null;
    }

    // Decrypt the future event
    const futureEvent = await decryptDraftContent(
      signer,
      userPubkey,
      draftEvent.content
    );

    // Extract metadata from future event tags
    const metadata = {
      title:
        futureEvent.tags.find((tag: string[]) => tag[0] === "title")?.[1] || "",
      genre: futureEvent.tags.find((tag: string[]) => tag[0] === "genre")?.[1],
      audioUrl: futureEvent.tags.find((tag: string[]) => tag[0] === "url")?.[1],
      coverUrl: futureEvent.tags.find(
        (tag: string[]) => tag[0] === "image"
      )?.[1],
      description: futureEvent.content,
      explicit:
        futureEvent.tags.find((tag: string[]) => tag[0] === "explicit")?.[1] ===
        "true",
      price: futureEvent.tags.find((tag: string[]) => tag[0] === "price")?.[1]
        ? parseInt(
            futureEvent.tags.find((tag: string[]) => tag[0] === "price")?.[1] ||
              "0"
          )
        : 0,
      tags: futureEvent.tags
        .filter((tag: string[]) => tag[0] === "t")
        .map((tag: string[]) => tag[1]),
    };

    return {
      draftId,
      draftEventId: draftEvent.id,
      draftCreatedAt: draftEvent.created_at,
      draftUpdatedAt: draftEvent.created_at, // Same as created for now
      title,
      futureEvent,
      metadata,
    };
  } catch (error) {
    console.error("Failed to parse draft track:", error);
    return null;
  }
}

// Parse draft event into DraftAlbum
export async function parseDraftAlbum(
  draftEvent: NostrEvent,
  signer: NostrSigner,
  userPubkey: string
): Promise<DraftAlbum | null> {
  try {
    const draftId = draftEvent.tags.find((tag) => tag[0] === "d")?.[1];
    const title =
      draftEvent.tags.find((tag) => tag[0] === "title")?.[1] ||
      "Untitled Draft";

    if (!draftId) {
      console.error("Draft event missing 'd' tag");
      return null;
    }

    // Check if content is empty (deleted draft)
    if (!draftEvent.content || draftEvent.content.trim() === "") {
      return null;
    }

    // Decrypt the future event
    const futureEvent = await decryptDraftContent(
      signer,
      userPubkey,
      draftEvent.content
    );

    // Extract track references
    const trackRefs = futureEvent.tags
      .filter((tag: string[]) => tag[0] === "track" && tag.length >= 3)
      .map((tag: string[]) => ({
        trackNumber: parseInt(tag[1]),
        eventId: tag[2],
        title:
          futureEvent.tags.find(
            (eTag: string[]) => eTag[0] === "e" && eTag[1] === tag[2]
          )?.[3] || "",
      }));

    // Extract metadata from future event tags
    const metadata = {
      title:
        futureEvent.tags.find((tag: string[]) => tag[0] === "title")?.[1] || "",
      artist:
        futureEvent.tags.find((tag: string[]) => tag[0] === "artist")?.[1] ||
        "",
      genre: futureEvent.tags.find((tag: string[]) => tag[0] === "genre")?.[1],
      description: futureEvent.content,
      coverUrl: futureEvent.tags.find(
        (tag: string[]) => tag[0] === "image"
      )?.[1],
      explicit:
        futureEvent.tags.find((tag: string[]) => tag[0] === "explicit")?.[1] ===
        "true",
      price: futureEvent.tags.find((tag: string[]) => tag[0] === "price")?.[1]
        ? parseInt(
            futureEvent.tags.find((tag: string[]) => tag[0] === "price")?.[1] ||
              "0"
          )
        : 0,
      tags: futureEvent.tags
        .filter((tag: string[]) => tag[0] === "t")
        .map((tag: string[]) => tag[1]),
      releaseDate: futureEvent.tags.find(
        (tag: string[]) => tag[0] === "released_at"
      )?.[1]
        ? new Date(
            parseInt(
              futureEvent.tags.find(
                (tag: string[]) => tag[0] === "released_at"
              )?.[1] || "0"
            )
          ).toISOString()
        : undefined,
      upc: futureEvent.tags.find((tag: string[]) => tag[0] === "upc")?.[1],
      label: futureEvent.tags.find((tag: string[]) => tag[0] === "label")?.[1],
      tracks: trackRefs,
    };

    return {
      draftId,
      draftEventId: draftEvent.id,
      draftCreatedAt: draftEvent.created_at,
      draftUpdatedAt: draftEvent.created_at,
      title,
      futureEvent,
      metadata,
    };
  } catch (error) {
    console.error("Failed to parse draft album:", error);
    return null;
  }
}
